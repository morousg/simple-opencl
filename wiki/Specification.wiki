#summary Library detailed description v0.09

= Specification Summary = 
(under construction)

<wiki:toc max_depth="2" />

= Introduction =

This section will describe the behaviour and the expected use of each function in the library, and introduce the two main data types: sclHard and sclSoft.

The functions are divided into three levels:

First level functions are the goal of this library, but can hide some API control that a developer might sometimes need, in order to write more sofisticated and optimized OpenCL Host code.

Second level functions provide a first interface that already reduces the amount of Host code, but give more control over the OpenCL API.

Third level functions are made to internally be used by second level functions. They can be used alone, if the user finds it usefull but their only goal is to provide services to second level funcions. So we don't recomend to use them alone. If you find a third level function usefull, take a look at where is it used in second level funcions because provably, you'll find the second level function still more usefull.

= SimpleOpenCL types =

In order to ease the use of OpenCL objects, SimpleOpenCL groups them in two structs: sclSoft and sclHard.

They are conceptually intuitive. sclHard groups all the objects related to OpenCL devices (hardware), and sclSoft groups all the objects related with device code (OpenCL C).

== sclHard ==

This are the eight components of sclHard:

{{{
typedef struct {
   cl_platform_id platform;
   cl_context context;
   cl_device_id device;
   cl_command_queue queue;
   int nComputeUnits;
   unsigned long int maxPointerSize;
   int deviceType;
   int devNum;
}sclHard;
}}}

To know more about platform, context, device and queue objects take a look at the OpenCL 1.1 specification at [http://www.khronos.org/opencl/ Khronos web page].

The variables nComputeUnits, deviceType and maxPointerSize are used to avoid further query's about the number of device compute units, the device type and the maximum pointer size for this device. 

Variables nComputeUnits and deviceType are used by the SimpleOpenCL function *sclGetFastestDevice* to decide wich is provably the fastest device for executing NDRange kernels.

The variable maxPointerSize is used by the SimpleOpenCL function *_sclSmartCreateContexts* in order to decide, among other variables, whether two or more devices will share the same context or not.

The variable devNum is used to numerically identify each device according to the numerical order in the original device list generated by *sclGetAllHardware* function. That allows to print at any time that information. For instance to see the execution sequence when using more than one device at once.

== sclSoft ==

This are the three components of sclSoft:

{{{
typedef struct{
   cl_program program;
   cl_kernel kernel;
   char kernelName[98];
}sclSoft;
}}}

To know more about program and kernel objects take a look at the OpenCL 1.1 specification at [http://www.khronos.org/opencl/ Khronos web page].

The variable kernelName is used to store the name of the kernel to make possible showing it to identify from which kernel are we getting debugging information if an error occurs.

= First level user functions ( Unitary Test Level ) =

This are the simpler functions to be used by someone who doesn't want to deal with OpenCL Host concepts. There is still some work to do to hide even more concepts like sclSoft and sclHard if possible. The goal for this level is to match the ideal of having a function to call an OpenCL kernel and asking the user only about the NDRange dimensions, OpenCL C memory hierarchy mapping and data flow (from Host to Device and from Device to Host).

== Getting sclSoft structs ==

=== sclGetCLSoftware ===

{{{
sclSoft sclGetCLSoftware( char* path, char* name, sclHard hardware );
}}}

This is the function to obtain an sclSoft struct, for a NDRange kernel.

== Getting sclHard structs ==

=== sclGetAllHardware ===

{{{
int sclGetAllHardware( sclHard** hardList );
}}}

This function returns the number of devices found, and stores them into a list of sclHard structs.

*UPDATE:* this function has changed since version 0.010_27_02_2013

This is the new function:

{{{
sclHard* sclGetAllHardware( int* found );
}}}

=== sclGetFastestDevice ===

{{{
sclHard sclGetFastestDevice( sclHard* hardList, int found );
}}}

This function returns the fastest device considering the number of compute units, independently of the device type. The decision criteria is very simple, but works pretty well. For instance, a 2 compute unit GPU will usually be slower than a 4 compute unit CPU, and a 6 compute unit GPU should be faster than a 4 compute unit CPU, although the decision criteria should be refined and more broadly tested.
 
== Executing an OpenCL C kernel ==

=== sclManageArgsLaunchKernel ===

{{{
cl_event sclManageArgsLaunchKernel( sclHard hardware, 
                                   sclSoft software, 
                                   size_t *global_work_size, 
                                   size_t *local_work_size,
                                   const char* sizesValues, 
                                   ... );
}}}

This must be the most weird function of all in the library. The functionality of this function is to execute a kernel taking the host pointers, automatically creating the device buffers, copying the data to be copied to the device, launch the kernel, wait for it to finish, read the results to be read and wait until they are completely read. Then, the host pointers to be updated with device results are updated. All that by calling a single function. Further versions will implement concurrent read/write and execution, and multi-device support.

To allow the function to know what has to be done with every argument in the variable argument field "...", sizesValues argument is passed with that information encoded in a printf style manner.

Here is an example:

We have an input variable, an output variable, and we also need a read/write __global variable and a __local variable to be used exclusively by the device.
{{{
cl_event event;
float *input;
float *output;
size_t input_size, output_size, global_size, local_size;

//get the data

input_size = DATA_SIZE * sizeof(float);
output_size = DATA_SIZE * sizeof(float);
global_size = X * sizeof(float);
local_size = BUFFER * sizeof(float);

event = sclManageArgsLaunchKernel( hardware,
                                   software,
                                   global_work_size,
                                   local_work_size,
                                   " input%r output%w global%g local%N ",
                                   input_size, input, output_size, output, global_size, local_size );
}}}
After calling that function, the variable output will be updated with the results generated by the GPU.

In the example i've put the variable names along with the %x indicators. This is not necessary, since the function only reads one character after the %.

clHard hardware is a struct generated with scl functions that contains all the necessary information of the hardware for it to be used.

clSoft software is a struct generated with scl functions that contains all the necessary information of the OpenCL kernel for it to be executed.

global_work_size and local_work_size are two pointers that contain the work item dimensions as required by clEnqueueNDRangeKernel function. See OpenCL 1.0 or 1.1 specification available on Khronos [http://www.khronos.org/opencl/ website].

const char ptr sizesValues contains the information of what are the arguments to be read next, and what to do with them. For that purpose you should write a string containing % followed by a character that describes what is to be read and what to do. For each argument you shoud write a % + character, though, if the size of the argument is needed, the function will read two arguments for a single %.

The characters that can be used, and its meanings are shown in the following list:

*%a* => Set a non pointer argument (or a cl_mem argument). The function will read a size_t argument, and a void ptr argument. It is intended for non pointer arguments like int, float etc... They must be passed as pointers ( "int a" must be passed as "&a"). When writing this indicator, you should pass two arguments in this order: size_t size, void ptr argument. Variable size is the size or the argument, and "argument" is the argument to be passed itself.

WARNING!! If the argument is of type cl_mem, then, the presence or absence of the data contained into the target hardware must be manually controlled.

*%N* => Set a __local memory argument. the function will only read a size_t argument and set it as a NULL argument. This will indicate the API that it is a _local argument with the read size.

*%w* => Set a host pointer argument to be written by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in write only mode. When the execution of the kernel is done, it will copy the contents of the buffer to the host pointer "void ptr arg".

*%r* => Set a host pointer argument to be read by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in read only mode. The contents of the host pointer "arg" will be copied to the buffer before kernel execution.

*%R* => Set a host pointer argument to be read and written by the device. The same as r and w, but the buffer will be set to read/write mode. So the contents of "arg" will be copied to the buffer before kernel execution and after that, the contents of the buffer will be copied back to the "arg" pointer.

*%g* => Set a device __global pointer to be read and written only by the device. The function will read only a "size_t size" argument. A cl_mem buffer of size "size_t size" will be created in read/write mode and set as a kernel argument. There will not be any data copy between the host and the device.

The event object returned is the kernel execution event. I use it to query the execution time of the kernel. Feel free to change the function code and return any other event.

= Second level user functions ( gives more control but requires more code ) =

This functions can be used by a user but are also used internally by first level SimpelOpenCL functions. They represent a compromise between ease of code and OpenCL API control.

== Device memory allocation ==

This functions create buffers and manipulate them, using less arguments than OpenCL native functions, and printing the error name if an error occurs.

=== sclMalloc ===

{{{
cl_mem sclMalloc( sclHard hardware, cl_int mode, size_t size );
}}}

This function returns a buffer object. "cl_mem" is a native OpenCL data type, and is the type of the buffer object returned.

It takes as arguments the sclHard hardware (really cl_context) in which the buffer will be created, the OpenCL buffer mode flag (CL_MEM_READ_ONLY | CL_MEM_WRITE_ONLY | CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR | CL_MEM_ALLOC_HOST_PTR | CL_MEM_COPY_HOST_PTR ), and the byte size of the buffer.

=== sclMallocWrite ===

{{{
cl_mem sclMallocWrite( sclHard hardware, cl_int mode, size_t size, void* hostPointer );
}}}

This function returns a buffer object. "cl_mem" is a native OpenCL data type, and is the type of the buffer object returned.

It takes as arguments the sclHard hardware (really cl_context) in which the buffer will be created, the OpenCL buffer mode flag (CL_MEM_READ_ONLY | CL_MEM_WRITE_ONLY | CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR | CL_MEM_ALLOC_HOST_PTR | CL_MEM_COPY_HOST_PTR ), and the byte size of the buffer.

In addition to creating a buffer it copies the contents of "hostPointer" to the buffer.

=== sclWrite ===

{{{
void sclWrite( sclHard hardware, size_t size, cl_mem buffer, void* hostPointer );
}}}

This function copies the contents of "hostPointer" pointer into "buffer" OpenCL buffer. 

This can be interpreted as copying a Host pointer into a Device memory, but in fact it's more like assigning a Host pointer to a Buffer that is tied to a Context. Then this buffer will be used by any device inside the same context.  

=== sclRead ===

{{{
void sclRead( sclHard hardware, size_t size, cl_mem buffer, void *hostPointer );
}}}

This function reads the contents of "buffer" and copy them into "hostPointer". 

== Release and retain OpenCL objects ==

=== sclReleaseClSoft ===

{{{
void sclReleaseClSoft( sclSoft soft );
}}}

This function deletes kernel and program objects within "soft" structure.

=== sclReleaseClHard ===

{{{
void sclReleaseClHard( sclHard hard );
}}}

This function decrements the command queue and context reference counters. When counters becomes zero and all commands queued have finished and the objects attached to context are released, then command queue and context are deleted.

== Debug functions ==

=== sclPrintErrorFlags ===

{{{
void sclPrintErrorFlags( cl_int flag );
}}}

This function prints error flag constant name through stderr.

=== sclPrintHardwareStatus ===

{{{
void sclPrintHardwareStatus( sclHard hardware );
}}}

This function print for an specific hardware its status. Status of the device could be "alive", "alive and available", "alive but not available" and "not alive".

=== sclPrintDeviceNamePlatforms ===

{{{
void sclPrintDeviceNamePlatforms( sclHard* hardList, int found );
}}}


This function print a list of devices with its "platform id", "platform name", "vendor" and "device name" based on the devices found at "hardList". "found" argument is used to limit the amount of elements listed.

== Device execution ==

=== sclLaunchKernel ===

{{{
cl_event sclLaunchKernel( sclHard hardware,sclSoft software, size_t *global_work_size, size_t *local_work_size );
}}}

This function enqueues a command to execute a kernel and wait to finish queued commands. "global_work_size" defines the number of global work items . "local_work_size" defines work group size (number of work items to make a work group).   

=== sclEnqueueKernel ===

{{{
cl_event sclEnqueueKernel( sclHard hardware, sclSoft software, size_t *global_work_size, size_t *local_work_size );
}}}

This function enqueues a command to execute a kernel. "global_work_size" defines the number of global work items . "local_work_size" defines work group size (number of work items to make a work group).   

=== sclSetArgsLaunchKernel ===

{{{
cl_event sclSetArgsLaunchKernel( sclHard hardware,
                                 sclSoft software,
                                 size_t *global_work_size,
                                 size_t *local_work_size,
                                 const char* sizesValues,
                                 ... );
}}}

=== sclSetArgsEnqueueKernel ===

{{{
cl_event sclSetArgsEnqueueKernel( sclHard hardware,
                                  sclSoft software,
                                  size_t *global_work_size,
                                  size_t *local_work_size,
                                  const char* sizesValues,
                                  ... );
}}}

== Event queries ==

{{{
cl_ulong sclGetEventTime( sclHard hardware, cl_event event );
}}}

This function returns the elapsed time passed for executing an event.

== Queue management ==

{{{
cl_int sclFinish( sclHard hardware );
}}}

Wait until all queued commands has been completed. This method could be used as a synchronization method.

== Kernel argument setting ==

=== sclSetKernelArg ===

{{{
void sclSetKernelArg( sclSoft software, int argnum, size_t typeSize, void *argument );
}}}

This function is used to assign a value for an specific argument, referred by an index, of a kernel.

=== sclSetKernelArgs ===

{{{
void sclSetKernelArgs( sclSoft software, const char *sizesValues, ... );
}}}

= Third level functions =

== Debug ==

== sclSoft creation ==

== sclHard creation ==
